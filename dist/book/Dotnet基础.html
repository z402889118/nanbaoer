<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>.NET基础 | 杨家瑞的博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="...">
    
    <link rel="preload" href="/assets/css/0.styles.9f84806b.css" as="style"><link rel="preload" href="/assets/js/app.2b8dd552.js" as="script"><link rel="preload" href="/assets/js/2.778bb4ad.js" as="script"><link rel="preload" href="/assets/js/1.50b457b8.js" as="script"><link rel="preload" href="/assets/js/23.b8493583.js" as="script"><link rel="prefetch" href="/assets/js/10.325b9f09.js"><link rel="prefetch" href="/assets/js/11.c62b6b34.js"><link rel="prefetch" href="/assets/js/12.ecdb524b.js"><link rel="prefetch" href="/assets/js/13.3f3f6a36.js"><link rel="prefetch" href="/assets/js/14.eb7a3d07.js"><link rel="prefetch" href="/assets/js/15.114dfd5c.js"><link rel="prefetch" href="/assets/js/16.85253907.js"><link rel="prefetch" href="/assets/js/17.c2838453.js"><link rel="prefetch" href="/assets/js/18.3256f17f.js"><link rel="prefetch" href="/assets/js/19.d8afd0ae.js"><link rel="prefetch" href="/assets/js/20.10e47ab9.js"><link rel="prefetch" href="/assets/js/21.33b300c9.js"><link rel="prefetch" href="/assets/js/22.52be2116.js"><link rel="prefetch" href="/assets/js/24.746e0918.js"><link rel="prefetch" href="/assets/js/3.af33e5d6.js"><link rel="prefetch" href="/assets/js/4.45665f8a.js"><link rel="prefetch" href="/assets/js/5.7098d77a.js"><link rel="prefetch" href="/assets/js/6.0c0a0f39.js"><link rel="prefetch" href="/assets/js/7.6a854e57.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.5e19b665.js">
    <link rel="stylesheet" href="/assets/css/0.styles.9f84806b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="杨家瑞的博客" class="logo"> <span class="site-name can-hide">杨家瑞的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="杨家瑞的博客" class="dropdown-title"><span class="title">杨家瑞的博客</span> <span class="arrow down"></span></button> <button type="button" aria-label="杨家瑞的博客" class="mobile-dropdown-title"><span class="title">杨家瑞的博客</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/mqyqingfeng" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/712139234359182/posts" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="杨家瑞的博客" class="dropdown-title"><span class="title">杨家瑞的博客</span> <span class="arrow down"></span></button> <button type="button" aria-label="杨家瑞的博客" class="mobile-dropdown-title"><span class="title">杨家瑞的博客</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/mqyqingfeng" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/712139234359182/posts" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/" class="sidebar-heading clickable router-link-active"><span>VuePress环境搭建</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/book/Nodejs 安装.html" class="sidebar-link">Node.js</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/book/Dotnet基础" class="sidebar-heading clickable open active"><span>基础学习</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/book/Dotnet基础.html" class="active sidebar-link">.NET基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/Dotnet基础.html#c-数据类型" class="sidebar-link">C#数据类型</a></li><li class="sidebar-sub-header"><a href="/book/Dotnet基础.html#c-变量" class="sidebar-link">c#变量</a></li><li class="sidebar-sub-header"><a href="/book/Dotnet基础.html#c-运算符" class="sidebar-link">c# 运算符</a></li><li class="sidebar-sub-header"><a href="/book/Dotnet基础.html#c-分支语句" class="sidebar-link">c#分支语句</a></li><li class="sidebar-sub-header"><a href="/book/Dotnet基础.html#c-循环语句" class="sidebar-link">c#循环语句</a></li><li class="sidebar-sub-header"><a href="/book/Dotnet基础.html#c-访问修饰符" class="sidebar-link">c# *访问修饰符</a></li><li class="sidebar-sub-header"><a href="/book/Dotnet基础.html#c-方法" class="sidebar-link">c#方法</a></li><li class="sidebar-sub-header"><a href="/book/Dotnet基础.html#efcore-基本使用" class="sidebar-link">EFCore 基本使用</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="net基础"><a href="#net基础" class="header-anchor">#</a> .NET基础</h1> <h2 id="c-数据类型"><a href="#c-数据类型" class="header-anchor">#</a> C#数据类型</h2> <p>C# 是面向对象的强类型高级语言，内置用于存储不同类型数据的内置数据类型。每种数据类型包含特定的取值范围，使用这些数据类型来表示在应用程序中存储的数据。数据类型进一步又被分为：</p> <div class="language- extra-class"><pre class="language-text"><code>• 值类型（Value types）
• 引用类型（Reference types）
• 指针类型（Pointer types）
</code></pre></div><p>值类型特点：<strong>变量直接存储其值，派生于 <code>System.ValueType</code></strong>。值类型又细分为整数值类型、浮点类型、简单类型、枚举类型、结构类型、可以为 <code>null</code> 的值类型。</p> <h3 id="一、-值类型-value-types"><a href="#一、-值类型-value-types" class="header-anchor">#</a> 一、*值类型（Value types）</h3> <p>值类型变量可以直接分配给一个值。它们是从类 <code>System.ValueType</code> 中派生的。值类型直接包含数据。比如 <code>int</code>、<code>char</code>、<code>float</code>，它们分别存储数字、字母、浮点数。当您声明一个 <code>int</code> 类型时，系统分配内存来存储值。</p> <table><thead><tr><th style="text-align:left;">类型</th> <th style="text-align:left;">描述</th> <th style="text-align:left;">范围</th> <th style="text-align:left;">默认值</th></tr></thead> <tbody><tr><td style="text-align:left;">bool</td> <td style="text-align:left;">布尔值</td> <td style="text-align:left;">True 或 False</td> <td style="text-align:left;">False</td></tr> <tr><td style="text-align:left;">byte</td> <td style="text-align:left;">8 位无符号整数</td> <td style="text-align:left;">0 到 255</td> <td style="text-align:left;">0</td></tr> <tr><td style="text-align:left;">char</td> <td style="text-align:left;">16 位 Unicode 字符</td> <td style="text-align:left;">U +0000 到 U +ffff</td> <td style="text-align:left;">'\0'</td></tr> <tr><td style="text-align:left;">decimal</td> <td style="text-align:left;">128 位精确的十进制值，28-29 有效位数（浮点型）</td> <td style="text-align:left;">(-7.9 x 1028 到 7.9 x 1028) / 100 到 28</td> <td style="text-align:left;">0.0M</td></tr> <tr><td style="text-align:left;">double</td> <td style="text-align:left;">64 位双精度浮点型</td> <td style="text-align:left;">(+/-)5.0 x 10-324 到 (+/-)1.7 x 10308</td> <td style="text-align:left;">0.0D</td></tr> <tr><td style="text-align:left;">float</td> <td style="text-align:left;">32 位单精度浮点型</td> <td style="text-align:left;">-3.4 x 1038 到 + 3.4 x 1038</td> <td style="text-align:left;">0.0F</td></tr> <tr><td style="text-align:left;">int</td> <td style="text-align:left;">32 位有符号整数类型</td> <td style="text-align:left;">-2,147,483,648 到 2,147,483,647</td> <td style="text-align:left;">0</td></tr> <tr><td style="text-align:left;">long</td> <td style="text-align:left;">64 位有符号整数类型</td> <td style="text-align:left;">-923,372,036,854,775,808 到 9,223,372,036,854,775,807</td> <td style="text-align:left;">0L</td></tr> <tr><td style="text-align:left;">sbyte</td> <td style="text-align:left;">8 位有符号整数类型</td> <td style="text-align:left;">-128 到 127</td> <td style="text-align:left;">0</td></tr> <tr><td style="text-align:left;">short</td> <td style="text-align:left;">16 位有符号整数类型</td> <td style="text-align:left;">-32,768 到 32,767</td> <td style="text-align:left;">0</td></tr> <tr><td style="text-align:left;">uint</td> <td style="text-align:left;">32 位无符号整数类型</td> <td style="text-align:left;">0 到 4,294,967,295</td> <td style="text-align:left;">0</td></tr> <tr><td style="text-align:left;">ulong</td> <td style="text-align:left;">64 位无符号整数类型</td> <td style="text-align:left;">0 到 18,446,744,073,709,551,615</td> <td style="text-align:left;">0</td></tr> <tr><td style="text-align:left;">ushort</td> <td style="text-align:left;">16 位无符号整数类型</td> <td style="text-align:left;">0 到 65,535</td> <td style="text-align:left;">0</td></tr></tbody></table> <p>如需得到一个类型或一个变量在特定平台上的准确尺寸，可以使用 <code>sizeof</code> 方法。表达式 <code>sizeof(type)</code> 产生以字节为单位存储对象或类型的存储尺寸。下面举例获取任何机器上 <code>int</code> 类型的存储尺寸：</p> <p>字节（Byte）是计算机信息技术用于计量存储容量的一种计量单位，也表示一些计算机编程语言中的数据类型和语言字符 [1] 。</p> <p>一个字节存储8位无符号数，储存的数值范围为0-255。如同字元一样，字节型态的变数只需要用一个位元组（8位元）的内存空间储存 [1] 。</p> <div class="language- extra-class"><pre class="language-text"><code>  namespace DataTypeApplication
      {
         class Program
         {
            static void Main(string[] args)
            {
               Console.WriteLine(&quot;Size of int: {0}&quot;, sizeof(int));
               Console.ReadLine();
            }
         }
      }
</code></pre></div><p>当上面的代码被编译和执行时，它会产生下列结果：</p> <div class="language- extra-class"><pre class="language-text"><code> Size of int: 4
</code></pre></div><h3 id="二、引用类型-reference-types"><a href="#二、引用类型-reference-types" class="header-anchor">#</a> 二、引用类型（Reference types）</h3> <p>引用类型不包含存储在变量中的实际数据，但它们包含对变量的引用。换句话说，它们指的是一个内存位置。使用多个变量时，引用类型可以指向一个内存位置。如果内存位置的数据是由一个变量改变的，其他变量会自动反映这种值的变化。内置的 引用类型有：<code>object</code>、<code>dynamic</code> 和 <code>string</code>。</p> <h4 id="_1-、对象-object-类型"><a href="#_1-、对象-object-类型" class="header-anchor">#</a> （1）、对象（Object）类型</h4> <p>对象（<code>Object</code>）类型 是 C# 通用类型系统（Common Type System - CTS）中所有数据类型的终极基类。<code>Object</code> 是 <code>System.Object</code> 类的别名。所以对象（<code>Object</code>）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值。但是，在分配值之前，需要先进行类型转换。<strong>当一个值类型转换为对象类型时，则被称为 装箱；另一方面，当一个对象类型转换为值类型时，则被称为 拆箱。</strong></p> <div class="language- extra-class"><pre class="language-text"><code>    object obj;    obj = 100; // 这是装箱
</code></pre></div><h4 id="_2-、动态-dynamic-类型"><a href="#_2-、动态-dynamic-类型" class="header-anchor">#</a> （2）、动态（Dynamic）类型</h4> <p>您可以存储任何类型的值在动态数据类型变量中。这些变量的类型检查是在运行时发生的。声明动态类型的语法：</p> <div class="language- extra-class"><pre class="language-text"><code>    dynamic &lt;variable_name&gt; = value;
</code></pre></div><p>例如：</p> <div class="language- extra-class"><pre class="language-text"><code>    dynamic d = 20;
</code></pre></div><p>动态类型与对象类型相似，但是对象类型变量的类型检查是在编译时发生的，而动态类型变量的类型检查是在运行时发生的。</p> <h4 id="_3-、字符串-string-类型"><a href="#_3-、字符串-string-类型" class="header-anchor">#</a> （3）、字符串（String）类型</h4> <p>字符串（<code>String</code>）类型 允许您给变量分配任何字符串值。字符串（<code>String</code>）类型是 <code>System.String</code> 类的别名。它是从对象（<code>Object</code>）类型派生的。字符串（<code>String</code>）类型的值可以通过两种形式进行分配：<strong>引号</strong>和 <strong>@引号</strong>。</p> <p>例如：</p> <div class="language- extra-class"><pre class="language-text"><code>    String str = &quot;runoob.com&quot;;
</code></pre></div><p>一个 @引号字符串：</p> <div class="language- extra-class"><pre class="language-text"><code>    @&quot;runoob.com&quot;;
</code></pre></div><p>C# <code>string</code> 字符串的前面可以加 <strong>@</strong>（称作&quot;逐字字符串&quot;）<strong>将转义字符（\）当作普通字符对待</strong>，比如：</p> <div class="language- extra-class"><pre class="language-text"><code>    string str = @&quot;C:\Windows&quot;;
</code></pre></div><p>等价于：</p> <div class="language- extra-class"><pre class="language-text"><code>    string str = &quot;C:\\Windows&quot;;
</code></pre></div><p>@ 字符串中可以任意换行，换行符及缩进空格都计算在字符串长度之内。</p> <div class="language- extra-class"><pre class="language-text"><code>       string str = @&quot;&lt;script type=&quot;&quot;text/javascript&quot;&quot;&gt;           &lt;!--           --&gt;       &lt;/script&gt;&quot;;
</code></pre></div><p>用户自定义引用类型有：<code>class</code>、<code>interface</code> 或 <code>delegate</code>。我们将在以后的章节中讨论这些类型。</p> <h3 id="三、-指针类型-pointer-types"><a href="#三、-指针类型-pointer-types" class="header-anchor">#</a> 三、*指针类型（Pointer types）</h3> <p>指针类型变量存储另一种类型的内存地址。C# 中的指针与 C 或 C++ 中的指针有相同的功能。</p> <p>声明指针类型的语法：</p> <div class="language- extra-class"><pre class="language-text"><code>    type* identifier;
</code></pre></div><p>例如：</p> <div class="language- extra-class"><pre class="language-text"><code> 复制代码    char* cptr;    int* iptr;
</code></pre></div><h3 id="四、枚举"><a href="#四、枚举" class="header-anchor">#</a> 四、枚举</h3> <p><code>enum</code> 是值类型数据类型。枚举用于声明命名整数常量的列表。可以直接在命名空间，类或结构中使用 <code>enum</code> 关键字定义。</p> <ul><li>枚举用于为每个常量指定一个名称，以便可以使用其名称引用常量整数默认情况下，枚举的第一个成员的值为 0，每个连续的枚举成员的值增加 1</li> <li>枚举可以包括数字数据类型的命名常量，例如 <code>byte</code>，<code>sbyte</code>，<code>short</code>，<code>ushort</code>，<code>int</code>，<code>uint</code>，<code>long</code> 或 <code>ulong</code></li> <li>枚举不能与字符串类型一起使用</li></ul> <p><code>Enum</code> 是一个抽象类，包含用于枚举的静态帮助器方法</p> <table><thead><tr><th style="text-align:left;"><strong>Enum method</strong></th> <th style="text-align:left;"><strong>Description</strong></th></tr></thead> <tbody><tr><td style="text-align:left;"><code>Format</code></td> <td style="text-align:left;">将指定的枚举类型值转换为指定的字符串格式</td></tr> <tr><td style="text-align:left;"><code>GetName</code></td> <td style="text-align:left;">返回指定枚举的指定值的常量的名称</td></tr> <tr><td style="text-align:left;"><code>GetNames</code></td> <td style="text-align:left;">返回指定枚举的所有常量的字符串名称数组</td></tr> <tr><td style="text-align:left;"><code>GetValues</code></td> <td style="text-align:left;">返回指定枚举的所有常量值的数组</td></tr> <tr><td style="text-align:left;"><code>object Parse(type, string)</code></td> <td style="text-align:left;">将一个或多个枚举常量的名称或数值的字符串表示形式转换为等效的枚举对象</td></tr> <tr><td style="text-align:left;"><code>bool TryParse(string, out TEnum)</code></td> <td style="text-align:left;">将一个或多个枚举常量的名称或数值的字符串表示形式转换为等效的枚举对象，返回值表示转换是否成功</td></tr></tbody></table> <h2 id="c-变量"><a href="#c-变量" class="header-anchor">#</a> c#变量</h2> <p>编译器需要用某个初始值对变量进行初始化之后才能在操作中使用该变量。</p> <p>在这里，<code>data_type</code> 必须是一个有效的 C# 数据类型，可以是 <code>char</code>、<code>int</code>、<code>float</code>、<code>double</code> 或其他用户自定义的数据类型。<code>variablename</code> 可以由一个或多个用逗号分隔的标识符名称组成。</p> <div class="language- extra-class"><pre class="language-text"><code>// 语法
&lt;datatype&gt;&lt;variablename&gt;=&lt;value&gt;;

// 示例
string name = &quot;wang&quot;;

// 同时声明多个
string name1,name2 = &quot;wang&quot;;

  int d = 3, f = 5;    /* 初始化 d 和 f. */
    byte z = 22;         /* 初始化 z. */
    double pi = 3.14159; /* 声明 pi 的近似值 */
    char x = 'x';        /* 变量 x 的值为 'x' */
</code></pre></div><h3 id="接受来自用户的值"><a href="#接受来自用户的值" class="header-anchor">#</a> 接受来自用户的值</h3> <p><code>System</code> 命名空间中的 <code>Console</code> 类提供了一个函数 <code>ReadLine()</code>，用于接收来自用户的输入，并把它存储到一个变量中。</p> <p>例如：</p> <div class="language- extra-class"><pre class="language-text"><code>        int num;
            num = Convert.ToInt32(Console.ReadLine());
            Console.WriteLine(num);
</code></pre></div><p><strong>注意</strong>：</p> <ul><li>变量是类或结构中的字段，如果没有显式初始化，创建这些变量时，默认值就是类型默认值</li> <li>方法的局部变量必须在代码中显式初始化才能在语句中使用</li> <li>在C#中实例化一个引用对象需要使用 <code>new</code> 关键字把该引用指向存储在堆上的一个对象</li></ul> <h2 id="c-运算符"><a href="#c-运算符" class="header-anchor">#</a> c# 运算符</h2> <p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C# 有丰富的内置运算符，分类如下：</p> <div class="language- extra-class"><pre class="language-text"><code>• 算术运算符
• 关系运算符
• 逻辑运算符
• 位运算符
• 赋值运算符
• 其他运算符
</code></pre></div><h3 id="一、算术运算符"><a href="#一、算术运算符" class="header-anchor">#</a> 一、算术运算符</h3> <p>下表显示了 C# 支持的所有算术运算符。假设变量 A 的值为 10，变量 B 的值为 20，则：</p> <table><thead><tr><th style="text-align:left;">运算符</th> <th style="text-align:left;">描述</th> <th style="text-align:left;">实例</th></tr></thead> <tbody><tr><td style="text-align:left;">+</td> <td style="text-align:left;">把两个操作数相加</td> <td style="text-align:left;">A + B 将得到 30</td></tr> <tr><td style="text-align:left;">-</td> <td style="text-align:left;">从第一个操作数中减去第二个操作数</td> <td style="text-align:left;">A - B 将得到 -10</td></tr> <tr><td style="text-align:left;">*</td> <td style="text-align:left;">把两个操作数相乘</td> <td style="text-align:left;">A B 将得到 200</td></tr> <tr><td style="text-align:left;">/</td> <td style="text-align:left;">分子除以分母</td> <td style="text-align:left;">B / A 将得到 2</td></tr> <tr><td style="text-align:left;">%</td> <td style="text-align:left;">取模运算符，整除后的余数</td> <td style="text-align:left;">B % A 将得到 0</td></tr> <tr><td style="text-align:left;">++</td> <td style="text-align:left;">自增运算符，整数值增加 1</td> <td style="text-align:left;">A++ 将得到 11</td></tr> <tr><td style="text-align:left;">—</td> <td style="text-align:left;">自减运算符，整数值减少 1</td> <td style="text-align:left;">A— 将得到 9</td></tr></tbody></table> <div class="language- extra-class"><pre class="language-text"><code>8 % 4      2余0      0

9 % 4      2余1      1

9 % 5      1余4      4

11 % 5     2余1     1

8 % 5      1余3      3

得到的结果为做除法后的余数，%是求余运算符


            int a = 21;
            int b = 10;
            int c;
            c = a + b;
            Console.WriteLine(&quot;Line 1 - c 的值是 {0}&quot;, c);
            c = a - b;
            Console.WriteLine(&quot;Line 2 - c 的值是 {0}&quot;, c);
            c = a * b;
            Console.WriteLine(&quot;Line 3 - c 的值是 {0}&quot;, c);
            c = a / b;
            Console.WriteLine(&quot;Line 4 - c 的值是 {0}&quot;, c);
            c = a % b;
            Console.WriteLine(&quot;Line 5 - c 的值是 {0}&quot;, c);
            // ++a 先进行自增运算再赋值
            c = ++a;
            Console.WriteLine(&quot;Line 6 - c 的值是 {0}&quot;, c);
            // 此时 a 的值为 22
            // --a 先进行自减运算再赋值
            c = --a;
            Console.WriteLine(&quot;Line 7 - c 的值是 {0}&quot;, c);
            Console.ReadLine();
            
    Line 1 - c 的值是 31
    Line 2 - c 的值是 11
    Line 3 - c 的值是 210
    Line 4 - c 的值是 2
    Line 5 - c 的值是 1
    Line 6 - c 的值是 22
    Line 7 - c 的值是 21
• c = a++: 先将 a 赋值给 c，再对 a 进行自增运算。
• c = ++a: 先将 a 进行自增运算，再将 a 赋值给 c 。
• c = a--: 先将 a 赋值给 c，再对 a 进行自减运算。
• c = --a: 先将 a 进行自减运算，再将 a 赋值给 c 。
示例：
               int a = 1;
                int b;
                // a++ **先赋值再进行自增运算**
                b = a++;
                Console.WriteLine(&quot;a = {0}&quot;, a);
                Console.WriteLine(&quot;b = {0}&quot;, b);
                Console.ReadLine();
                // ++a **先进行自增运算再赋值**
                a = 1; // 重新初始化 a
                b = ++a;
                Console.WriteLine(&quot;a = {0}&quot;, a);
                Console.WriteLine(&quot;b = {0}&quot;, b);
                Console.ReadLine();
                // a-- 先赋值再进行自减运算
                a = 1;  // 重新初始化 a
                b= a--;
                Console.WriteLine(&quot;a = {0}&quot;, a);
                Console.WriteLine(&quot;b = {0}&quot;, b);
                Console.ReadLine();
                // --a 先进行自减运算再赋值
                a = 1;  // 重新初始化 a
                b= --a;
                Console.WriteLine(&quot;a = {0}&quot;, a);
                Console.WriteLine(&quot;b = {0}&quot;, b);
                Console.ReadLine();
</code></pre></div><h3 id="二、关系运算符"><a href="#二、关系运算符" class="header-anchor">#</a> 二、关系运算符</h3> <p>下表显示了 C# 支持的所有关系运算符。假设变量 A 的值为 10，变量 B 的值为 20，则：</p> <table><thead><tr><th style="text-align:left;">运算符</th> <th style="text-align:left;">描述</th> <th style="text-align:left;">实例</th></tr></thead> <tbody><tr><td style="text-align:left;"><code>==</code></td> <td style="text-align:left;">检查两个操作数的值是否相等，如果相等则条件为真。</td> <td style="text-align:left;">(A <code>== B)</code> 不为真。</td></tr> <tr><td style="text-align:left;"><code>!=</code></td> <td style="text-align:left;">检查两个操作数的值是否相等，如果不相等则条件为真。</td> <td style="text-align:left;"><code>(A != B)</code> 为真。</td></tr> <tr><td style="text-align:left;"><code>&gt;</code></td> <td style="text-align:left;">检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td> <td style="text-align:left;"><code>(A &gt; B)</code> 不为真。</td></tr> <tr><td style="text-align:left;"><code>&lt;</code></td> <td style="text-align:left;">检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td> <td style="text-align:left;"><code>(A &lt; B)</code> 为真。</td></tr> <tr><td style="text-align:left;"><code>&gt;=</code></td> <td style="text-align:left;">检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td> <td style="text-align:left;"><code>(A &gt;= B)</code> 不为真。</td></tr> <tr><td style="text-align:left;"><code>&lt;=</code></td> <td style="text-align:left;">检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td> <td style="text-align:left;"><code>(A &lt;= B)</code> 为真。</td></tr></tbody></table> <h3 id="三、逻辑运算符"><a href="#三、逻辑运算符" class="header-anchor">#</a> 三、逻辑运算符</h3> <p>下表显示了 C# 支持的所有逻辑运算符。假设变量 A 为布尔值 <code>true</code>，变量 B 为布尔值 <code>false</code>，则：</p> <table><thead><tr><th style="text-align:left;">运算符</th> <th style="text-align:left;">描述</th> <th style="text-align:left;">实例</th></tr></thead> <tbody><tr><td style="text-align:left;"><code>&amp;&amp;</code></td> <td style="text-align:left;">称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td> <td style="text-align:left;"><code>(A &amp;&amp; B)</code> 为假。</td></tr> <tr><td style="text-align:left;">II</td> <td style="text-align:left;">称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td> <td style="text-align:left;">(A II B) 为真。</td></tr> <tr><td style="text-align:left;">!</td> <td style="text-align:left;">称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td> <td style="text-align:left;"><code>!(A &amp;&amp; B)</code> 为真。</td></tr></tbody></table> <h3 id="四、赋值运算符"><a href="#四、赋值运算符" class="header-anchor">#</a> 四、赋值运算符</h3> <p>下表列出了 C# 支持的赋值运算符：</p> <table><thead><tr><th style="text-align:left;">运算符</th> <th style="text-align:left;">描述</th> <th style="text-align:left;">实例</th></tr></thead> <tbody><tr><td style="text-align:left;"><code>=</code></td> <td style="text-align:left;">简单的赋值运算符，把右边操作数的值赋给左边操作数</td> <td style="text-align:left;">C = A + B 将把 A + B 的值赋给 C</td></tr> <tr><td style="text-align:left;"><code>+=</code></td> <td style="text-align:left;">加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td> <td style="text-align:left;">C += A 相当于 C = C + A</td></tr> <tr><td style="text-align:left;"><code>-=</code></td> <td style="text-align:left;">减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td> <td style="text-align:left;">C -= A 相当于 C = C - A</td></tr> <tr><td style="text-align:left;"><code>*=</code></td> <td style="text-align:left;">乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td> <td style="text-align:left;">C <em>= A 相当于 C = C</em> A</td></tr> <tr><td style="text-align:left;"><code>/=</code></td> <td style="text-align:left;">除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td> <td style="text-align:left;">C /= A 相当于 C = C / A</td></tr> <tr><td style="text-align:left;"><code>%=</code></td> <td style="text-align:left;">求模且赋值运算符，求两个操作数的模赋值给左边操作数</td> <td style="text-align:left;">C %= A 相当于 C = C % A</td></tr> <tr><td style="text-align:left;"><code>&lt;&lt;=</code></td> <td style="text-align:left;">左移且赋值运算符</td> <td style="text-align:left;"><code>C &lt;&lt;= 2</code> 等同于 <code>C = C &lt;&lt; 2</code></td></tr> <tr><td style="text-align:left;"><code>&gt;&gt;=</code></td> <td style="text-align:left;">右移且赋值运算符</td> <td style="text-align:left;"><code>C &gt;&gt;= 2</code> 等同于 <code>C = C &gt;&gt; 2</code></td></tr> <tr><td style="text-align:left;"><code>&amp;=</code></td> <td style="text-align:left;">按位与且赋值运算符</td> <td style="text-align:left;"><code>C &amp;= 2</code> 等同于 <code>C = C &amp; 2</code></td></tr> <tr><td style="text-align:left;"><code>^=</code></td> <td style="text-align:left;">按位异或且赋值运算符</td> <td style="text-align:left;"><code>C ^= 2</code> 等同于 <code>C = C ^ 2</code></td></tr> <tr><td style="text-align:left;">I=</td> <td style="text-align:left;">按位或且赋值运算符</td> <td style="text-align:left;">C I= 2 等同于 C = C I 2</td></tr></tbody></table> <div class="language- extra-class"><pre class="language-text"><code>                int a = 21;
                int c;
                c = a;
                Console.WriteLine(&quot;Line 1 - =  c 的值 = {0}&quot;, c);
                c += a;
                Console.WriteLine(&quot;Line 2 - += c 的值 = {0}&quot;, c);
                c -= a;
                Console.WriteLine(&quot;Line 3 - -=  c 的值 = {0}&quot;, c);
                c *= a;
                Console.WriteLine(&quot;Line 4 - *=  c 的值 = {0}&quot;, c);
                c /= a;
                Console.WriteLine(&quot;Line 5 - /=  c 的值 = {0}&quot;, c);
                c = 200;
                c %= a;
                Console.WriteLine(&quot;Line 6 - %=  c 的值 = {0}&quot;, c);
                c &lt;&lt;= 2;
                Console.WriteLine(&quot;Line 7 - &lt;&lt;=  c 的值 = {0}&quot;, c);
                c &gt;&gt;= 2;
                Console.WriteLine(&quot;Line 8 - &gt;&gt;=  c 的值 = {0}&quot;, c);
                c &amp;= 2;
                Console.WriteLine(&quot;Line 9 - &amp;=  c 的值 = {0}&quot;, c);
                c ^= 2;
                Console.WriteLine(&quot;Line 10 - ^=  c 的值 = {0}&quot;, c);
                c |= 2;
                Console.WriteLine(&quot;Line 11 - |=  c 的值 = {0}&quot;, c);
                Console.ReadLine();
                
                
                
    Line 1 - =     c 的值 = 21
    Line 2 - +=    c 的值 = 42
    Line 3 - -=    c 的值 = 21
    Line 4 - *=    c 的值 = 441
    Line 5 - /=    c 的值 = 21
    Line 6 - %=    c 的值 = 11
    Line 7 - &lt;&lt;=    c 的值 = 44
    Line 8 - &gt;&gt;=    c 的值 = 11
    Line 9 - &amp;=    c 的值 = 2
    Line 10 - ^=    c 的值 = 0
    Line 11 - |=    c 的值 = 2
</code></pre></div><h3 id="六、其他运算符"><a href="#六、其他运算符" class="header-anchor">#</a> 六、其他运算符</h3> <p>下表列出了 C# 支持的其他一些重要的运算符，包括 <code>sizeof</code>、<code>typeof</code> 和 <code>? :</code>。</p> <table><thead><tr><th style="text-align:left;">运算符</th> <th style="text-align:left;">描述</th> <th style="text-align:left;">实例</th></tr></thead> <tbody><tr><td style="text-align:left;">sizeof()</td> <td style="text-align:left;">返回数据类型的大小。</td> <td style="text-align:left;"><code>sizeof(int)</code>，将返回 4.</td></tr> <tr><td style="text-align:left;">typeof()</td> <td style="text-align:left;">返回 class 的类型。</td> <td style="text-align:left;"><code>typeof(StreamReader);</code></td></tr> <tr><td style="text-align:left;">&amp;</td> <td style="text-align:left;">返回变量的地址。</td> <td style="text-align:left;">&amp;a; 将得到变量的实际地址。</td></tr> <tr><td style="text-align:left;"></td> <td style="text-align:left;">变量的指针。</td> <td style="text-align:left;">a; 将指向一个变量。</td></tr> <tr><td style="text-align:left;">? :</td> <td style="text-align:left;">条件表达式</td> <td style="text-align:left;">如果条件为真 ? 则为 X : 否则为 Y</td></tr> <tr><td style="text-align:left;">is</td> <td style="text-align:left;">判断对象是否为某一类型。</td> <td style="text-align:left;"><code>If( Ford is Car) // 检查 Ford 是否是 Car 类的一个对象。</code></td></tr> <tr><td style="text-align:left;">as</td> <td style="text-align:left;">强制转换，即使转换失败也不会抛出异常。</td> <td style="text-align:left;"><code>Object obj = new StringReader(&quot;Hello&quot;);``StringReader r = obj as StringReader;</code></td></tr> <tr><td style="text-align:left;">？</td> <td style="text-align:left;">可空类型和运算符</td> <td style="text-align:left;">int? a = null;<br>int? c = a + 4; //c=null</td></tr> <tr><td style="text-align:left;">？？</td> <td style="text-align:left;">空合并运算符</td> <td style="text-align:left;">空合并运算符 <code>??</code> 提供了快捷方式处理可空类型和引用类型时表示 <code>null</code> 可能的值。如果第一个操作数不是<code>null</code>，值就等于第一个操作数的值/如果第一个操作数是<code>null</code>，值就等于第二个操作数的值</td></tr> <tr><td style="text-align:left;">checked/unchecked</td> <td style="text-align:left;"></td> <td style="text-align:left;">如果把代码块标记为 <code>checked</code> ， <code>CLR</code> 就会执行栈溢出检测，如果要禁止栈溢出，则可以把代码标记 <code>unchecked</code> 。</td></tr></tbody></table> <div class="language- extra-class"><pre class="language-text"><code>            /* sizeof 运算符的实例 */
             Console.WriteLine(&quot;int 的大小是 {0}&quot;, sizeof(int));
             Console.WriteLine(&quot;short 的大小是 {0}&quot;, sizeof(short));
             Console.WriteLine(&quot;double 的大小是 {0}&quot;, sizeof(double));
             /* 三元运算符符的实例 */
             int a, b;
             a = 10;
             b = (a == 1) ? 20 : 30;
             Console.WriteLine(&quot;b 的值是 {0}&quot;, b);
             b = (a == 10) ? 20 : 30;
             Console.WriteLine(&quot;b 的值是 {0}&quot;, b);
             // 空合并运算符
             int? a = null;
             int b;
             b = a ?? 10;//第一个操作数是null，值为第二个操作数.10
             a = 3;
             b = a ?? 10;//第一个操作数不是null，值为第一个操作数.3
             // checked/unchecked
           //byte类型最大取值255
            byte a = 255;
            checked
           {
              a++;
           }
//这里如果不加checed.++后输出0(不会抛异常，但会丢失数据，溢出的位会被舍弃，所以值为0)，加上后会抛出栈溢出异常
Console.WriteLine(a);
             Console.ReadLine();
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>    int 的大小是 4
    short 的大小是 2
    double 的大小是 8
    b 的值是 30
    b 的值是 20
</code></pre></div><h3 id="七、c-中的运算符优先级"><a href="#七、c-中的运算符优先级" class="header-anchor">#</a> 七、C# 中的运算符优先级</h3> <p>运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。</p> <p>例如 <code>x = 7 + 3 *2*</code><em>，在这里，x 被赋值为 13，而不是 20，因为运算符</em> 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。</p> <p>下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。</p> <table><thead><tr><th style="text-align:left;">类别</th> <th style="text-align:left;">运算符</th> <th style="text-align:left;">结合性</th></tr></thead> <tbody><tr><td style="text-align:left;">后缀</td> <td style="text-align:left;"><code>() [] -&gt; . ++ - -</code></td> <td style="text-align:left;">从左到右</td></tr> <tr><td style="text-align:left;">一元</td> <td style="text-align:left;"><code>+ - ! ~ ++ - - (type) *&amp; sizeof*</code></td> <td style="text-align:left;">从右到左</td></tr> <tr><td style="text-align:left;">乘除</td> <td style="text-align:left;"><code>/ %</code></td> <td style="text-align:left;">从左到右</td></tr> <tr><td style="text-align:left;">加减</td> <td style="text-align:left;"><code>+ -</code></td> <td style="text-align:left;">从左到右</td></tr> <tr><td style="text-align:left;">移位</td> <td style="text-align:left;"><code>&lt;&lt; &gt;&gt;</code></td> <td style="text-align:left;">从左到右</td></tr> <tr><td style="text-align:left;">关系</td> <td style="text-align:left;"><code>&lt; &lt;= &gt; &gt;=</code></td> <td style="text-align:left;">从左到右</td></tr> <tr><td style="text-align:left;">相等</td> <td style="text-align:left;"><code>== !=</code></td> <td style="text-align:left;">从左到右</td></tr> <tr><td style="text-align:left;">位与 AND</td> <td style="text-align:left;">&amp;</td> <td style="text-align:left;">从左到右</td></tr> <tr><td style="text-align:left;">位异或 XOR</td> <td style="text-align:left;">^</td> <td style="text-align:left;">从左到右</td></tr> <tr><td style="text-align:left;">位或 OR</td> <td style="text-align:left;">I</td> <td style="text-align:left;">从左到右</td></tr> <tr><td style="text-align:left;">逻辑与 AND</td> <td style="text-align:left;">&amp;&amp;</td> <td style="text-align:left;">从左到右</td></tr> <tr><td style="text-align:left;">逻辑或 OR</td> <td style="text-align:left;">II</td> <td style="text-align:left;">从左到右</td></tr> <tr><td style="text-align:left;">条件</td> <td style="text-align:left;"><code>?:</code></td> <td style="text-align:left;">从右到左</td></tr> <tr><td style="text-align:left;">赋值</td> <td style="text-align:left;"><code>= += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^=</code> I=</td> <td style="text-align:left;">从右到左</td></tr> <tr><td style="text-align:left;">逗号</td> <td style="text-align:left;">,</td> <td style="text-align:left;">从左到右</td></tr></tbody></table> <p>示例：</p> <div class="language- extra-class"><pre class="language-text"><code>             int a = 20;
             int b = 10;
             int c = 15;
             int d = 5;
             int e;
             e = (a + b) * c / d;     // ( 30 * 15 ) / 5
             Console.WriteLine(&quot;(a + b) * c / d 的值是 {0}&quot;, e);
             e = ((a + b) * c) / d;   // (30 * 15 ) / 5
             Console.WriteLine(&quot;((a + b) * c) / d 的值是 {0}&quot;, e);
             e = (a + b) * (c / d);   // (30) * (15/5)
             Console.WriteLine(&quot;(a + b) * (c / d) 的值是 {0}&quot;, e);
             e = a + (b * c) / d;    //  20 + (150/5)
             Console.WriteLine(&quot;a + (b * c) / d 的值是 {0}&quot;, e);
             Console.ReadLine();
</code></pre></div><h3 id="八、-预处理器指令"><a href="#八、-预处理器指令" class="header-anchor">#</a> 八、*预处理器指令</h3> <ul><li><code>#region/#endregion</code> 指令用于把一段代码标记为有给定名称的一个块</li> <li><code>define/#undef</code> 结合 <code>#if/#elif/endif</code> 实现条件编译</li></ul> <div class="language- extra-class"><pre class="language-text"><code>#define debug
using System;

namespace CSharp.Study.Test
{
    class Program
    {
        static void Main(string[] args)
        {
#if debug
            Console.WriteLine(&quot;debug&quot;);
#else
          Console.WriteLine(&quot;other&quot;);
#endif
        }

    }
}
</code></pre></div><h2 id="c-分支语句"><a href="#c-分支语句" class="header-anchor">#</a> c#分支语句</h2> <p>分支结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。下面是大多数编程语言中典型的分支结构的一般形式：</p> <p>分支语句大致有<code>if</code> <code>else</code> <code>switch</code></p> <p><strong>变量作用域</strong></p> <p>变量作用域指：可以访问该变量的代码区域</p> <p><strong>注意</strong>：</p> <ul><li>只要类在某个作用域内，其字段(也称为成员变量)也在该作用域内</li> <li>局部变量存在于表示声明该变量的块语句或方法结束的右花括号之前的作用域内</li> <li>在 <code>for</code>、 <code>while</code> <code>if</code> <code>else</code> <code>switch</code> 或类似语句中声明的局部变量存在于该循环体内</li></ul> <h3 id="一、if-else-语句-可以延续if-else-使用-else-if则须再加判断"><a href="#一、if-else-语句-可以延续if-else-使用-else-if则须再加判断" class="header-anchor">#</a> 一、if…else 语句（可以延续if else 使用  else if则须再加判断）</h3> <p>一个 <code>if</code> 语句 后可跟一个可选的 <code>else</code> 语句，<code>else</code> 语句在布尔表达式为假时执行。</p> <div class="language- extra-class"><pre class="language-text"><code>    if(boolean_expression)
    {
       /* 如果布尔表达式为真将执行的语句 */
    }
    else if((boolean_expression)
    {
       /* 如果布尔表达式为真将执行的语句 */
    }
    else{
      /* 如果布尔表达式为假将执行的语句 */
    }
</code></pre></div><h3 id="二、switch-语句"><a href="#二、switch-语句" class="header-anchor">#</a> 二、switch 语句</h3> <p>一个 <code>switch</code> 语句允许测试一个变量等于多个值时的情况。每个值称为一个 <code>case</code>，且被测试的变量会对每个 <code>switch case</code> 进行检查。</p> <blockquote><div class="language- extra-class"><pre class="language-text"><code>/* 局部变量定义 */
               char grade = 'B';
               switch (grade)
               {
                   case 'A':
                       Console.WriteLine(&quot;很棒！&quot;);
                       break;
                   case 'B':
                   case 'C':
                       Console.WriteLine(&quot;做得好&quot;);
                       break;
                   case 'D':
                       Console.WriteLine(&quot;您通过了&quot;);
                       break;
                   case 'F':
                       Console.WriteLine(&quot;最好再试一下&quot;);
                       break;
                   default:
                       Console.WriteLine(&quot;无效的成绩&quot;);
                       break;
               }
               Console.WriteLine(&quot;您的成绩是 {0}&quot;, grade);
               Console.ReadLine();
</code></pre></div></blockquote> <p><strong>switch 语句必须遵循下面的规则：</strong></p> <ul><li><code>switch</code> 语句中的 <code>expression</code> 必须是一个整型或枚举类型，或者是一个 <code>class</code> 类型，其中 <code>class</code> 有一个单一的转换函数将其转换为整型或枚举类型。</li> <li>在一个 <code>switch</code> 中可以有任意数量的 <code>case</code> 语句。每个 <code>case</code> 后跟一个要比较的值和一个冒号。</li> <li><code>case</code> 的 <code>constant-expression</code> 必须与 <code>switch</code> 中的变量具有相同的数据类型，且必须是一个常量。</li> <li>当被测试的变量等于 <code>case</code> 中的常量时，<code>case</code> 后跟的语句将被执行，直到遇到 <code>break</code> 语句为止。</li> <li>当遇到 <code>break</code> 语句时，<code>switch</code> 终止，控制流将跳转到 <code>switch</code> 语句后的下一行。</li> <li>不是每一个 <code>case</code> 都需要包含 <code>break</code>。如果 <code>case</code> 语句为空，则可以不包含 <code>break</code>，控制流将会 继续 后续的 <code>case</code>，直到遇到 <code>break</code> 为止。</li> <li>C# 不允许从一个开关部分继续执行到下一个开关部分。如果 <code>case</code> 语句中有处理语句，则必须包含 <code>break</code> 或其他跳转语句。</li> <li>一个 <code>switch</code> 语句可以有一个可选的 <code>default case</code>，出现在 <code>switch</code> 的结尾。<code>default case</code> 可用于在上面所有 <code>case</code> 都不为真时执行一个任务。<code>default case</code> 中的 <code>break</code> 语句不是必需的。</li> <li>C# 不支持从一个 <code>case</code> 标签显式贯穿到另一个 <code>case</code> 标签。如果要使 C# 支持从一个 <code>case</code> 标签显式贯穿到另一个 <code>case</code> 标签，可以使用 <code>goto</code> 一个 <code>switch-case</code> 或 <code>goto default</code>。</li></ul> <h3 id="三、-三目运算符"><a href="#三、-三目运算符" class="header-anchor">#</a> 三、？：三目运算符</h3> <p>我们已经在前面的章节中讲解了 条件运算符 <code>? :</code>，可以用来替代 <code>if…else</code> 语句。它的一般形式如下：</p> <div class="language- extra-class"><pre class="language-text"><code>    Exp1 ? Exp2 : Exp3;
</code></pre></div><p>其中，<code>Exp1</code>、<code>Exp2</code> 和 <code>Exp3</code> 是表达式。请注意，冒号的使用和位置。</p> <p><code>?</code> 表达式的值是由 <code>Exp1</code> 决定的。如果 <code>Exp1</code> 为真，则计算 <code>Exp2</code> 的值，结果即为整个 <code>?</code> 表达式的值。如果 <code>Exp1</code> 为假，则计算 <code>Exp3</code> 的值，结果即为整个 <code>?</code> 表达式的值。</p> <h2 id="c-循环语句"><a href="#c-循环语句" class="header-anchor">#</a> c#循环语句</h2> <h3 id="一、while-循环"><a href="#一、while-循环" class="header-anchor">#</a> 一、while 循环</h3> <p>只要给定的条件为真，C# 中的 <code>while</code> 循环语句会重复执行一个目标语句。</p> <p>在这里，<code>Console.WriteLine(&quot;a 的值： {0}&quot;, a);</code> 可以是一个单独的语句，也可以是几个语句组成的代码块。<code>a &lt; 20</code> 可以是任意的表达式，当为任意非零值时都为真。当条件为真时执行循环。</p> <p>当条件为假时，程序流将继续执行紧接着循环的下一条语句。</p> <p>在这里，<code>while</code> 循环的关键点是循环可能一次都不会执行。当条件被测试且结果为假时，会跳过循环主体，直接执行紧接着 <code>while</code> 循环的下一条语句。</p> <div class="language- extra-class"><pre class="language-text"><code>/* 局部变量定义 */
                int a = 10;
                /* while 循环执行 */
                while (a &lt; 20)// 也就是说a=20或a&gt;20则不会执行循环
                {
                    Console.WriteLine(&quot;a 的值： {0}&quot;, a);
                    a++;
                }
                Console.ReadLine();
                因为是a++
                所以执行结果是
                10
                11
                12
                13
                14
                15
                16
                17
                18
                19
</code></pre></div><h3 id="二、for-foreach-循环"><a href="#二、for-foreach-循环" class="header-anchor">#</a> 二、for /foreach 循环</h3> <p><strong>下面是 for 循环的控制流：</strong></p> <ul><li><code>int a = 10</code>会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。</li> <li>接下来，会判断 <code>a &lt; 20</code>。如果为真，则执行循环主体。如果为假，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。</li> <li>在执行完 for 循环主体后，控制流会跳回上面的 <code>a = a + 1</code>语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。</li> <li>条件再次被判断。如果为真，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为假时，for 循环终止。</li></ul> <div class="language- extra-class"><pre class="language-text"><code> /* for 循环执行 */
                for (int a = 10; a &lt; 20; a = a + 1)
                {
                    Console.WriteLine(&quot;a 的值： {0}&quot;, a);
                }
                Console.ReadLine();
</code></pre></div><h4 id="foreach"><a href="#foreach" class="header-anchor">#</a> foreach</h4> <p>C# 也支持 <code>foreach</code> 循环，使用<code>foreach</code>可以迭代数组或者一个集合对象。</p> <p><strong>以下实例有三个部分：</strong></p> <ul><li>通过 <code>foreach</code> 循环输出整型数组中的元素。</li> <li>通过 <code>for</code> 循环输出整型数组中的元素。</li> <li><code>foreach</code> 循环设置数组元素的计算器。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>int[] fibarray = new int[] { 0, 1, 1, 2, 3, 5, 8, 13 };
            foreach (int element in fibarray)
            {
                System.Console.WriteLine(element);
            }
            System.Console.WriteLine();
            // 类似 foreach 循环
            for (int i = 0; i &lt; fibarray.Length; i++)
            {
                System.Console.WriteLine(fibarray[i]);
            }
            System.Console.WriteLine();
            // 设置集合中元素的计算器
            int count = 0;
            foreach (int element in fibarray)
            {
                count += 1;
                System.Console.WriteLine(&quot;Element #{0}: {1}&quot;, count, element);
            }
            System.Console.WriteLine(&quot;Number of elements in the array: {0}&quot;, count);
</code></pre></div><h3 id="三、do-while-循环"><a href="#三、do-while-循环" class="header-anchor">#</a> 三、do…while 循环</h3> <p>不像 <code>for</code> 和 <code>while</code> 循环，它们是在循环头部测试循环条件。<code>do…while</code> 循环是在循环的尾部检查它的条件。</p> <p><code>do…whil</code>e 循环与 <code>while</code> 循环类似，但是 <code>do…while</code> 循环会确保至少执行一次循环。</p> <p>请注意，条件表达式出现在循环的尾部，所以循环中的 <code>Console.WriteLine(&quot;a 的值： {0}&quot;, a); a = a + 1;</code> 会在条件被测试之前至少执行一次。</p> <p>如果条件为真，控制流会跳转回上面的 <code>do</code>，然后重新执行循环中的 <code>Console.WriteLine(&quot;a 的值： {0}&quot;, a); a = a + 1;</code>。这个过程会不断重复，直到给定条件变为假为止。</p> <div class="language- extra-class"><pre class="language-text"><code> /* 局部变量定义 */
                int a = 10;
                /* do 循环执行 */
                do
                {
                   Console.WriteLine(&quot;a 的值： {0}&quot;, a);
                    a = a + 1;
                } while (a &lt; 20);// 条件
                Console.ReadLine();
</code></pre></div><h3 id="四、循环控制语句"><a href="#四、循环控制语句" class="header-anchor">#</a> 四、循环控制语句</h3> <p>循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。</p> <p>C# 提供了下列的控制语句：</p> <ul><li><code>break</code>语句。终止 <code>loop</code> 或 <code>switch</code> 语句，程序流将继续执行紧接着 <code>loop</code> 或 <code>switch</code> 的下一条语句。</li> <li><code>continue</code>语句。引起循环跳过主体的剩余部分，立即重新开始测试条件。</li></ul> <h4 id="break语句"><a href="#break语句" class="header-anchor">#</a> break语句</h4> <p><strong>C# 中 break 语句有以下两种用法：</strong></p> <ul><li>当 <code>break</code> 语句出现在一个循环内时，循环会立即终止，且程序流将继续执行紧接着循环的下一条语句。</li> <li>它可用于终止 <code>switch</code> 语句中的一个 <code>case</code>。</li></ul> <p></p> <p>如果您使用的是嵌套循环（即一个循环内嵌套另一个循环），break 语句会停止执行最内层的循环，然后开始执行该块之后的下一行代码。</p> <div class="language- extra-class"><pre class="language-text"><code>                /* 局部变量定义 */
                int a = 10;
                /* while 循环执行 */
                while (a &lt; 20)
                {
                    Console.WriteLine(&quot;a 的值： {0}&quot;, a);
                    a++;
                    if (a &gt; 15)
                    {
                        /* 使用 break 语句终止 loop */
                        break;
                    }
                }
                Console.ReadLine();
</code></pre></div><h4 id="continue-语句"><a href="#continue-语句" class="header-anchor">#</a> continue 语句</h4> <p>C# 中的 <code>continue</code> 语句有点像 <code>break</code> 语句。但它不是强迫终止，<code>continue</code> 会跳过当前循环中的代码，强迫开始下一次循环。对于 <code>for</code> 循环，<code>continue</code> 语句会导致执行条件测试和循环增量部分。对于 <code>while</code> 和 <code>do…while</code> 循环，<code>continue</code> 语句会导致程序控制回到条件测试上。</p> <div class="language- extra-class"><pre class="language-text"><code>/* 局部变量定义 */
                int a = 10;
                /* do 循环执行 */
                do
                {
                    if (a == 15)
                    {
                        /* 跳过迭代 */
                        a = a + 1;
                        continue;
                    }
                    Console.WriteLine(&quot;a 的值： {0}&quot;, a);
                    a++;
                } while (a &lt; 20);
                Console.ReadLine();
</code></pre></div><h2 id="c-访问修饰符"><a href="#c-访问修饰符" class="header-anchor">#</a> c# *访问修饰符</h2> <p>封装 被定义为&quot;把一个或多个项目封闭在一个物理的或者逻辑的包中&quot;。在面向对象程序设计方法论中，封装是为了防止对实现细节的访问。</p> <p>抽象和封装是面向对象程序设计的相关特性。抽象允许相关信息可视化，封装则使开发者实现所需级别的抽象。</p> <p>C# 封装根据具体的需要，设置使用者的访问权限，并通过 访问修饰符 来实现。</p> <p>一个 访问修饰符 定义了一个类成员的范围和可见性。C# 支持的访问修饰符如下所示：</p> <ul><li>Public：所有对象都可以访问；</li> <li>Private：对象本身在对象内部可以访问；</li> <li>Protected：只有该类对象及其子类对象可以访问</li> <li>Internal：同一个程序集的对象可以访问；</li> <li>Protected internal：该程序集内的派生类访问，是protected和internal的交集；</li></ul> <h3 id="一、public-访问修饰符"><a href="#一、public-访问修饰符" class="header-anchor">#</a> 一、Public 访问修饰符</h3> <p><code>Public</code> 访问修饰符允许一个类将其成员变量和成员函数暴露给其他的函数和对象。任何公有成员可以被外部的类访问。</p> <div class="language- extra-class"><pre class="language-text"><code> class Rectangle
        {
            //成员变量
            public double length;
            public double width;
            public double GetArea()
            {
                return length * width;
            }
            public void Display()
            {
                Console.WriteLine(&quot;长度： {0}&quot;, length);
                Console.WriteLine(&quot;宽度： {0}&quot;, width);
                Console.WriteLine(&quot;面积： {0}&quot;, GetArea());
            }
        }// Rectangle 结束
        class ExecuteRectangle
        {
            static void Main(string[] args)
            {
                Rectangle r = new Rectangle();
                r.length = 4.5;
            r.width = 3.5;
                r.Display();
                Console.ReadLine();
            }
        }
</code></pre></div><p>在上面的实例中，成员变量 <code>length</code> 和 <code>width</code> 被声明为 <code>public</code>，所以它们可以被函数 <code>Main()</code> 使用 <code>Rectangle</code> 类的实例 <code>r</code> 访问。</p> <p>成员函数 <code>Display()</code> 和 <code>GetArea()</code> 可以直接访问这些变量。</p> <p>成员函数 <code>Display()</code> 也被声明为 <code>public</code>，所以它也能被 <code>Main()</code> 使用 <code>Rectangle</code> 类的实例 <code>r</code> 访问。</p> <h3 id="二、private-访问修饰符"><a href="#二、private-访问修饰符" class="header-anchor">#</a> 二、Private 访问修饰符</h3> <p><code>Private</code> 访问修饰符允许一个类将其成员变量和成员函数对其他的函数和对象进行隐藏。只有同一个类中的函数可以访问它的私有成员。即使是类的实例也不能访问它的私有成员。</p> <div class="language- extra-class"><pre class="language-text"><code>  //成员变量
            private double length;
            private double width;
            public void Acceptdetails()
            {
                Console.WriteLine(&quot;请输入长度：&quot;);
                length = Convert.ToDouble(Console.ReadLine());
                Console.WriteLine(&quot;请输入宽度：&quot;);
                width = Convert.ToDouble(Console.ReadLine());
            }
            public double GetArea()
            {
                return length * width;
            }
            public void Display()
            {
                Console.WriteLine(&quot;长度： {0}&quot;, length);
                Console.WriteLine(&quot;宽度： {0}&quot;, width);
                Console.WriteLine(&quot;面积： {0}&quot;, GetArea());
            }
        }//end class Rectangle    
        class ExecuteRectangle
        {
            static void Main(string[] args)
            {
                Rectangle r = new Rectangle();
                r.Acceptdetails();
                r.Display();
                Console.ReadLine();
            }
        }
</code></pre></div><p>在上面的实例中，成员变量 <code>length</code> 和 <code>width</code> 被声明为 <code>private</code>，所以它们不能被函数 <code>Main()</code> 访问。</p> <p>成员函数 <code>AcceptDetails()</code> 和 <code>Display()</code> 可以访问这些变量。</p> <p>由于成员函数 <code>AcceptDetails()</code> 和 <code>Display()</code> 被声明为 <code>public</code>，所以它们可以被 <code>Main()</code> 使用 <code>Rectangle</code> 类的实例 <code>r</code> 访问。</p> <h3 id="三、protected-访问修饰符"><a href="#三、protected-访问修饰符" class="header-anchor">#</a> 三、Protected 访问修饰符</h3> <p><code>Protected</code> 访问修饰符允许子类访问它的基类的成员变量和成员函数。这样有助于实现继承。我们将在继承的章节详细讨论这个。更详细地讨论这个。</p> <h3 id="四、internal-访问修饰符"><a href="#四、internal-访问修饰符" class="header-anchor">#</a> 四、Internal 访问修饰符</h3> <p><code>Internal</code> 访问说明符允许一个类将其成员变量和成员函数暴露给当前程序中的其他函数和对象。换句话说，带有 <code>internal</code> 访问修饰符的任何成员可以被定义在该成员所定义的应用程序内的任何类或方法访问。</p> <div class="language- extra-class"><pre class="language-text"><code> class Rectangle
        {
            //成员变量
            internal double length;
            internal double width;
            double GetArea()
            {
                return length * width;
            }
           public void Display()
            {
                Console.WriteLine(&quot;长度： {0}&quot;, length);
                Console.WriteLine(&quot;宽度： {0}&quot;, width);
                Console.WriteLine(&quot;面积： {0}&quot;, GetArea());
            }
        }//end class Rectangle    
        class ExecuteRectangle
        {
            static void Main(string[] args)
            {
                Rectangle r = new Rectangle();
                r.length = 4.5;
                r.width = 3.5;
                r.Display();
                Console.ReadLine();
            }
        }
</code></pre></div><p>在上面的实例中，请注意成员函数 <code>GetArea()</code> 声明的时候不带有任何访问修饰符。如果没有指定访问修饰符，则使用类成员的默认访问修饰符，即为 <code>private</code>。</p> <h3 id="五、protected-internal-访问修饰符"><a href="#五、protected-internal-访问修饰符" class="header-anchor">#</a> 五、Protected Internal 访问修饰符</h3> <p><code>Protected Internal</code> 访问修饰符允许在本类,派生类或者包含该类的程序集中访问。这也被用于实现继承。</p> <h2 id="c-方法"><a href="#c-方法" class="header-anchor">#</a> c#方法</h2> <p>当定义一个方法时，从根本上说是在声明它的结构的元素。在 C# 中，定义方法的语法如下：</p> <div class="language- extra-class"><pre class="language-text"><code>      &lt;Access Specifier&gt; &lt;Return Type&gt; &lt;Method Name&gt;(Parameter List)      {         Method Body      }
</code></pre></div><p></p> <p><strong>下面是方法的各个元素：</strong></p> <ul><li>Access Specifier：访问修饰符，这个决定了变量或方法对于另一个类的可见性。</li> <li>Return type：返回类型，一个方法可以返回一个值。返回类型是方法返回的值的数据类型。如果方法不返回任何值，则返回类型为 void。</li> <li>Method name：方法名称，是一个唯一的标识符，且是大小写敏感的。它不能与类中声明的其他标识符相同。</li> <li>Parameter list：参数列表，使用圆括号括起来，该参数是用来传递和接收方法的数据。参数列表是指方法的参数类型、顺序和数量。参数是可选的，也就是说，一个方法可能不包含参数。</li> <li>Method body：方法主体，包含了完成任务所需的指令集。</li></ul> <h4 id="一、创建方法"><a href="#一、创建方法" class="header-anchor">#</a> 一、创建方法</h4> <div class="language- extra-class"><pre class="language-text"><code> public int FindMax(int num1, int num2)
         {
            /* 局部变量声明 */
            int result;
            if (num1 &gt; num2)
               result = num1;
            else
               result = num2;
            return result;
         }
</code></pre></div><h4 id="二、c-中调用方法"><a href="#二、c-中调用方法" class="header-anchor">#</a> 二、C# 中调用方法</h4> <div class="language- extra-class"><pre class="language-text"><code> public int FindMax(int num1, int num2)
            {
               /* 局部变量声明 */
               int result;
               if (num1 &gt; num2)
                  result = num1;
               else
                  result = num2;
               return result;
            }
            static void Main(string[] args)
            {
               /* 局部变量定义 */
               int a = 100;
               int b = 200;
               int ret;
               NumberManipulator n = new NumberManipulator();
               //调用 FindMax 方法
               ret = n.FindMax(a, b);
               Console.WriteLine(&quot;最大值是： {0}&quot;, ret );
               Console.ReadLine();
            }
</code></pre></div><h3 id="三、递归方法调用"><a href="#三、递归方法调用" class="header-anchor">#</a> 三、递归方法调用</h3> <p>一个方法可以自我调用。这就是所谓的 递归。下面的实例使用递归函数计算一个数的阶乘：</p> <div class="language- extra-class"><pre class="language-text"><code>      using System;
      namespace CalculatorApplication
      {
          class NumberManipulator
          {
              public int factorial(int num)
              {
                  /* 局部变量定义 */
                  int result;
                  if (num == 1)
                  {
                      return 1;
                  }
                  else
                  {
                      result = factorial(num - 1) * num;
                      return result;
                  }
              }
              static void Main(string[] args)
              {
                  NumberManipulator n = new NumberManipulator();
                  //调用 factorial 方法
                  Console.WriteLine(&quot;6 的阶乘是： {0}&quot;, n.factorial(6));
                  Console.WriteLine(&quot;7 的阶乘是： {0}&quot;, n.factorial(7));
                  Console.WriteLine(&quot;8 的阶乘是： {0}&quot;, n.factorial(8));
                  Console.ReadLine();
              }
          }
      }
</code></pre></div><p>当上面的代码被编译和执行时，它会产生下列结果：</p> <div class="language- extra-class"><pre class="language-text"><code>    6 的阶乘是： 720    7 的阶乘是： 5040    8 的阶乘是： 40320
</code></pre></div><p>计算过程：</p> <blockquote><p>1
2
6
24
120   120 * 6
6 的阶乘是： 720
1
2
6
24
120
720     720 * 7
7 的阶乘是： 5040
1
2
6
24
120
720
5040     5040*8
8 的阶乘是： 40320</p></blockquote> <h3 id="四、-参数传递"><a href="#四、-参数传递" class="header-anchor">#</a> 四、*参数传递</h3> <p>当调用带有参数的方法时，您需要向方法传递参数。在 C# 中，有三种向方法传递参数的方式：</p> <table><thead><tr><th style="text-align:left;">方式</th> <th style="text-align:left;">描述</th></tr></thead> <tbody><tr><td style="text-align:left;">值参数</td> <td style="text-align:left;">这种方式复制参数的实际值给函数的形式参数，实参和形参使用的是两个不同内存中的值。在这种情况下，当形参的值发生改变时，<strong>不会影响实参的值</strong>，从而保证了实参数据的安全。</td></tr> <tr><td style="text-align:left;">引用参数</td> <td style="text-align:left;">这种方式复制参数的内存位置的引用给形式参数。这意味着，**当形参的值发生改变时，同时也改变实参的值。**ref 初始化必须有值</td></tr> <tr><td style="text-align:left;">输出参数</td> <td style="text-align:left;">这种方式可以返回多个值。out输出参数  不管是否传递这个参数都会从清0</td></tr></tbody></table> <h4 id="按值传递参数"><a href="#按值传递参数" class="header-anchor">#</a> 按值传递参数</h4> <p>这是参数传递的默认方式。在这种方式下，当调用一个方法时，会为每个值参数创建一个新的存储位置。实际参数的值会复制给形参，实参和形参使用的是两个不同内存中的值。所以，当形参的值发生改变时，不会影响实参的值，从而保证了实参数据的安全。下面的实例演示了这个概念：</p> <div class="language- extra-class"><pre class="language-text"><code>      using System;
      namespace CalculatorApplication
      {
         class NumberManipulator
         {
            public void swap(int x, int y)
            {
               int temp;
               temp = x; /* 保存 x 的值 */
               x = y;    /* 把 y 赋值给 x */
               y = temp; /* 把 temp 赋值给 y */
            }
            static void Main(string[] args)
            {
               NumberManipulator n = new NumberManipulator();
               /* 局部变量定义 */
               int a = 100;
               int b = 200;
               Console.WriteLine(&quot;在交换之前，a 的值： {0}&quot;, a);
               Console.WriteLine(&quot;在交换之前，b 的值： {0}&quot;, b);
               /* 调用函数来交换值 */
               n.swap(a, b);
               Console.WriteLine(&quot;在交换之后，a 的值： {0}&quot;, a);
               Console.WriteLine(&quot;在交换之后，b 的值： {0}&quot;, b);
               Console.ReadLine();
            }
         }
      }
</code></pre></div><h4 id="按引用传递参数"><a href="#按引用传递参数" class="header-anchor">#</a> 按引用传递参数</h4> <p>引用参数是一个对变量的内存位置的引用。当按引用传递参数时，与值参数不同的是，它不会为这些参数创建一个新的存储位置。引用参数表示与提供给方法的实际参数具有相同的内存位置。</p> <div class="language- extra-class"><pre class="language-text"><code>      using System;
      namespace CalculatorApplication
      {
         class NumberManipulator
         {
            public void swap(ref int x, ref int y)
            {
               int temp;
               temp = x; /* 保存 x 的值 */
               x = y;    /* 把 y 赋值给 x */
               y = temp; /* 把 temp 赋值给 y */
             }
            static void Main(string[] args)
            {
               NumberManipulator n = new NumberManipulator();
               /* 局部变量定义 */
               int a = 100;
               int b = 200;
               Console.WriteLine(&quot;在交换之前，a 的值： {0}&quot;, a);
               Console.WriteLine(&quot;在交换之前，b 的值： {0}&quot;, b);
               /* 调用函数来交换值 */
               n.swap(ref a, ref b);
               Console.WriteLine(&quot;在交换之后，a 的值： {0}&quot;, a);
               Console.WriteLine(&quot;在交换之后，b 的值： {0}&quot;, b);
               Console.ReadLine();
            }
         }
      }
</code></pre></div><h4 id="按输出传递参数"><a href="#按输出传递参数" class="header-anchor">#</a> 按输出传递参数</h4> <p><code>return</code> 语句可用于只从函数中返回一个值。但是，可以使用 <strong>输出参数</strong> 来从函数中返回两个值。输出参数会把方法输出的数据赋给自己，其他方面与引用参数相似。</p> <div class="language- extra-class"><pre class="language-text"><code>      using System;
      namespace CalculatorApplication
      {
         class NumberManipulator
         {
            public void getValue(out int x )
            {
               int temp = 5;
               x = temp;
            }
            static void Main(string[] args)
            {
               NumberManipulator n = new NumberManipulator();
               /* 局部变量定义 */
               int a = 100;
               Console.WriteLine(&quot;在方法调用之前，a 的值： {0}&quot;, a);
               /* 调用函数来获取值 */
               n.getValue(out a);
               Console.WriteLine(&quot;在方法调用之后，a 的值： {0}&quot;, a);
               Console.ReadLine();
            }
         }
      }
</code></pre></div><p>提供给输出参数的变量不需要赋值。当需要从一个参数没有指定初始值的方法中返回值时，输出参数特别有用。请看下面的实例，来理解这一点：</p> <div class="language- extra-class"><pre class="language-text"><code>      using System;
      namespace CalculatorApplication
      {
         class NumberManipulator
         {
            public void getValues(out int x, out int y )
            {
                Console.WriteLine(&quot;请输入第一个值： &quot;);
                x = Convert.ToInt32(Console.ReadLine());
                Console.WriteLine(&quot;请输入第二个值： &quot;);
                y = Convert.ToInt32(Console.ReadLine());
            }
            static void Main(string[] args)
            {
               NumberManipulator n = new NumberManipulator();
               /* 局部变量定义 */
               int a , b;
               /* 调用函数来获取值 */
               n.getValues(out a, out b);
               Console.WriteLine(&quot;在方法调用之后，a 的值： {0}&quot;, a);
               Console.WriteLine(&quot;在方法调用之后，b 的值： {0}&quot;, b);
               Console.ReadLine();
            }
         }
      }
</code></pre></div><h1 id="orm"><a href="#orm" class="header-anchor">#</a> ORM</h1> <p><strong>object Realation Maping</strong> 数据库关系映射工具</p> <p>其实是为了关系性数据库和C# 语言的映射 让开发者用对象操作关系数据库</p> <p>ORM 就是将C#代码 转换成sql语句来操作数据</p> <p>EFCore 官方推荐 尽量屏蔽底层数据库差异（模型驱动）（约定大于配置）</p> <p>Dapper 数据库驱动</p> <p><strong>EFCore 与EF 差异</strong></p> <blockquote><p>EF 有DBFirst、ModelFirst 、CodeFrist</p> <p>EFCore 不支持模型优先 推荐使用代码优先</p> <p>EF不会再有新的特性增加 未来.net 有ORM的更新都会添加到EFCore</p></blockquote> <p>EFCore 是对于底层ADO.NETCore的封装，因此ADO.NETCore支持的数据库不一定被EFCore支持</p> <p>概念：Migration 数据库迁移</p> <blockquote><p>面向对象的ORM开发种，数据库不是程序员手动创建的而是由Migration 工具生成的。关系数据库只是盛放模型数据的一个媒介而已，理想状态下程序员不需要关心数据库的操作</p> <p>根据对象的定义变化，自动更新数据库中的表以及表结构的操作叫做Migration （迁移）</p> <p>迁移可以分为多步（项目进化），也可以回滚</p></blockquote> <h2 id="efcore-基本使用"><a href="#efcore-基本使用" class="header-anchor">#</a> EFCore 基本使用</h2> <ul><li><p><code>Microsoft.EntityFrameworkCore.SqlServer</code> 下载对应<code>nuget</code>包  （这个包安装不需要安装efcore的包单独装也可以）</p></li> <li><p>建表中对应实体</p> <div class="language-c# extra-class"><pre class="language-text"><code>public class SysUser
{
     /// &lt;summary&gt;
        /// 账号
        /// &lt;/summary&gt;
        public string UserName { get; set; }

        /// &lt;summary&gt;
        /// 密码
        /// &lt;/summary&gt;
        public string PassWord { get; set; }

        /// &lt;summary&gt;
        /// 头像
        /// &lt;/summary&gt;
        public string Avatar { get; set; }
}
</code></pre></div></li> <li><p>实体的配置类</p> <div class="language-c# extra-class"><pre class="language-text"><code> public class EntityConfiguration : IEntityTypeConfiguration&lt;SysUser&gt;
    {
        public void Configure(EntityTypeBuilder&lt;SysUser&gt; builder)
        {
            builder.ToTable(&quot;SysUser&quot;);
        }
    }
</code></pre></div></li> <li><p>DbContext配置</p> <div class="language-c# extra-class"><pre class="language-text"><code> public class MyDbContext : DbContext
    {
        public DbSet&lt;SysUser&gt; Users { get; set; }
        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            base.OnConfiguring(optionsBuilder);
            optionsBuilder.UseSqlServer(&quot;Server=WIN-OBVK2686PPL;uid=sa;pwd=123456;Database=CoreSchool;MultipleActiveResultSets=true;pooling=true;min pool size=5;max pool size=32767;connect timeout=20;Encrypt=True;TrustServerCertificate=True;&quot;);
        }
        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);
            // 从当前程序集反射加载所有实现IEntityTypeConfiguration
            modelBuilder.ApplyConfigurationsFromAssembly(this.GetType().Assembly);
        }

    }
</code></pre></div></li> <li><p>使用<code>Migration</code> 工具生成表 可以每次都对每次的命令写上对应的别名</p> <div class="language-c# extra-class"><pre class="language-text"><code>安装对应 nuget 包 Microsoft.EntityFrameworkCore.Tools

 初次加载（需要在DbContext所在的层使用）
    Add-Migration Init
  操作数据库
    Update-Database
    
    
 （增删改字段都是这个流程）
之后 不用再执行   Add-Migration Init   可以改为 Add-Migration 别名（操作列等方便记录）
</code></pre></div></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/book/Nodejs 安装.html" class="prev">
        Node.js
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.2b8dd552.js" defer></script><script src="/assets/js/2.778bb4ad.js" defer></script><script src="/assets/js/1.50b457b8.js" defer></script><script src="/assets/js/23.b8493583.js" defer></script>
  </body>
</html>
